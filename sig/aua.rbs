module Aua
  VERSION: String

  class Error < StandardError
  end

  type char = String

  module Text
    class Cursor
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (Integer, Integer) -> void
      def advance: () -> void
      def newline: () -> void
    end

    class Document
      attr_reader text: String
      attr_reader cursor: Cursor
      attr_reader position: Integer

      def initialize: (String) -> void
      def advance: (?Integer) -> void
      def current: () -> char?
      def peek: () -> char?
      def peek_at: (Integer) -> char?
      def peek_n: (Integer) -> Array[char]
      def slice: (Integer, Integer) -> String?
      def indicate: () -> Array[String]
      def finished?: () -> bool
      def caret: () -> Cursor
      def content: () -> String
    end

    def self.indicate: (String, Cursor) -> Array[String]
  end

  module Syntax
    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader at: ::Aua::Text::Cursor
      def initialize: (type: Symbol, value: untyped, at: ::Aua::Text::Cursor) -> void
    end

    ONE_CHAR_TOKEN_NAMES: Hash[String, Symbol]
    TWO_CHAR_TOKEN_NAMES: Hash[String, Symbol]
    THREE_CHAR_TOKEN_NAMES: Hash[String, Symbol]

    KEYWORDS: Set[Symbol]
  end

  type token = Syntax::Token
  type matchy = Regexp | String

  class Lex
    class Handler
      def initialize: (Lex) -> void

      def comment: (String) -> token?
      def plus: (String) -> token?
      def star: (String) -> token?
      def slash: (String) -> token?
      def pow: (String) -> token?
      def lparen: (String) -> token?
      def rparen: (String) -> token?
      def number: (String) -> token?
      def equals: (String) -> token?
      def identifier: (String) -> token?
      def string: (String) -> token?
      def minus: (String) -> token?
      def whitespace: (String) -> void
      def unexpected: (String) -> void
      def prompt: (String) -> token?

      private

      def lens: () -> Lex::Lens
      def advance: (?Integer) -> void
      def recognize: () -> Lex::Recognizer
      def t: (Symbol, untyped, at: Text::Cursor) -> Syntax::Token
           | (Symbol, untyped) -> Syntax::Token
           | (Symbol) -> Syntax::Token
      def current_char: () -> char
      def next_char: () -> char
      def next_next_char: () -> char
      def current_pos: () -> Integer
      def eof?: () -> bool

      def self.unexpected_character_message: (Lex::Lens) -> String
    end

    class Recognizer
      KEYWORDS: Set[Symbol]
      MAX_STRING_LENGTH: Integer
      def initialize: (Lex) -> void
      def identifier: () -> token
      def number_lit: () -> token
      def string: (?String) -> token
      def number_token_from_string: (String, bool) -> token
      def current_char: () -> char
      def advance: (?Integer) -> void
      def t: (Symbol, untyped, at: Text::Cursor) -> Syntax::Token
           | (Symbol, untyped) -> Syntax::Token
           | (Symbol) -> Syntax::Token
      def eof?: () -> bool
      def current_pos: () -> Integer
      def next_char: () -> char
      def next_next_char: () -> char

      private

      def consume_number: () -> [bool, Integer]
      def consume_string_chars: (String) -> String
      def encode_string: (String, quote: String) -> Syntax::Token
      def string_end?: (Array[String]) -> bool
      def invalid_token_message: (String) -> String
      def check_number_followed_by_identifier: () -> void
    end

    class Lens
      def initialize: (Text::Document) -> void
      def current_pos: () -> Integer
      def current_line: () -> Integer
      def current_column: () -> Integer
      def current_char: () -> char
      def describe: () -> String
      def describe_character: (char) -> String
      def identify: (message: String, hint: String) -> String
      def eof?: () -> bool
      def peek: () -> char
      def peek_n: (Integer) -> Array[char]
      def more?: () -> bool
    end

    include Syntax

    @doc: Text::Document
    @lens: Lens
    @recognize: Recognizer
    @handle: Handler

    def initialize: (String) -> void

    def tokens: () -> Enumerator[token]
    def advance: (?Integer) -> void
    def recognize: () -> Lex::Recognizer
    def caret: () -> Text::Cursor
    def slice_from: (Integer) -> String?

    def t: (Symbol, untyped, at: Text::Cursor) -> Syntax::Token
         | (Symbol, untyped) -> Syntax::Token
         | (Symbol) -> Syntax::Token

    private

    def tokenize: () { (token) -> void } -> void
    def accept: () -> untyped
    def accept_n: (Array[char]) -> untyped
    def accept_token: () -> token?
    def consume_until_acceptance: () -> token?
    def current_char: () -> char
    def current_column: () -> Integer
    def current_line: () -> Integer
    def current_pos: () -> Integer
    def each_token: () { (token) -> void } -> void
    def eof?: () -> bool
    def handle: () -> Lex::Handler
    def pattern_match?: (String | Regexp, String) -> bool
    def token_names: (Integer) -> untyped
    def unexpected_character_message: () -> String
    def yield_lexeme: () { (token) -> void } -> void
  end

  module AST
    class Node
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader at: ::Aua::Text::Cursor
      def initialize: (type: Symbol, value: untyped, at: ::Aua::Text::Cursor) -> void
    end
  end

  module Grammar
    PRIMARY_NAMES: Hash[Symbol, Symbol]
    BINARY_PRECEDENCE: Hash[Symbol, Integer]

    attr_reader parse: Parse
    def s: (Symbol, *untyped) -> AST::Node
    def normalize_maybe_list: (untyped) -> untyped
    class Primitives
      include Grammar
      def initialize: (Parse) -> void
      def parse_negation: () -> AST::Node
      def parse_id: () -> AST::Node
      def parse_int: () -> AST::Node
      def parse_nihil: () -> AST::Node
      def parse_float: () -> AST::Node
      def parse_bool: () -> AST::Node
      def parse_str: () -> AST::Node
      def parse_simple_str: () -> AST::Node
      def parse_parens: () -> AST::Node
      def parse_generative_lit: () -> AST::Node

      private

      def parse_one: (Symbol) -> AST::Node
    end
  end
  def self.s: (Symbol, *untyped) -> AST::Node

  class Parse
    include Grammar

    @tokens: Enumerator[token]
    @buffer: Array[token?]

    attr_reader current_token: token

    def initialize: (Enumerator[token]) -> void
    def tree: () -> AST::Node
    def consume: (Symbol) -> void
               | (Symbol, untyped?) -> void
    def next_token: () -> token?
    def peek_token: () -> token?
    def parse: () -> AST::Node
    def parse_expression: () -> AST::Node
    def parse_assignment: () -> AST::Node?
    def parse_binop: (?Integer) -> AST::Node
    def parse_primary: () -> AST::Node
    def parse_command: () -> AST::Node?
    def parse_unary: () -> AST::Node?
    def parse_conditional: () -> AST::Node?
    def parse_condition_body: () -> [AST::Node, AST::Node?]
    def unexpected_tokens?: () -> bool
    def unexpected_token: () -> untyped
    def self.ast: (Array[token]) -> AST::Node
    def binary_op?: (Symbol) -> bool
    def advance: () -> void

    def precedent?: (Symbol, Integer) -> bool
    def consume_binary_op: (AST::Node) -> AST::Node
    def parse_call: () -> AST::Node?
  end

  class Obj
    def klass: () -> Klass
    def introspect: () -> String
    def pretty: () -> String
    def self.aura_methods: () -> Hash[Symbol, Proc]
    def self.aura_method: (Symbol) -> Proc
    def self.define_aura_method: (Symbol) { (*untyped) -> untyped } -> void
    def aura_respond_to?: (Symbol) -> bool
    def aura_send: (Symbol, *untyped) -> untyped
  end

  class Klass < Obj
    def initialize: (String, Obj) -> void
    def klass: () -> Klass
    def introspect: () -> String
    def self.klass: () -> Klass
    def self.obj: () -> Klass
  end

  class Nihil < Obj
    def klass: () -> Klass
    def name: () -> String
    def value: () -> nil
    def introspect: () -> String
  end

  class Int < Obj
    def initialize: (Integer) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: Integer
  end

  class Float < Obj
    def initialize: (::Float) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: ::Float
  end

  class Str < Obj
    def initialize: (String) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: String
  end

  class Bool < Obj
    def initialize: (bool) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: bool
  end

  class Time < Obj
    def initialize: (::Time) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    def self.now: () -> Time

    attr_reader value: ::Time
  end

  # class Box[T] < Obj
  #   def initialize: (T) -> void
  #   def klass: () -> Klass
  #   def name: () -> String
  #   def introspect: () -> String
  #   attr_reader value: T
  # end

  # class Rec < Box[Hash[String, Obj]]
  #   def initialize: (String, Hash[String, Obj]) -> void
  #   def klass: () -> Klass
  #   def name: () -> String
  #   def introspect: () -> String
  # end

  class Statement
    attr_reader type: Symbol
    attr_reader value: untyped
    def initialize: (type: Symbol, value: untyped) -> void
  end

  module Semantics
    MEMO: String
    def self.inst: (Symbol, *untyped) -> Statement
  end

  class Context
    def initialize: (String) -> void
    def source_document: () -> Text::Document
  end

  type primary = Int | Float | Str | Bool | Nihil
  type environment = Hash[String, untyped]

  type statement = Array[Statement] | Statement | Array[primary] | primary

  class VM
    class Translator
      def initialize: (VM) -> void
      def environment: () -> environment
      def reify_primary: (AST::Node) -> primary
      def translate_negation: (AST::Node) -> Array[Statement]
      def translate: (AST::Node) -> statement
      def translate_assignment: (AST::Node) -> Array[Statement]
      def translate_basic: (AST::Node) -> statement
      def translate_binop: (AST::Node) -> statement
      def translate_if: (AST::Node) -> statement
      def translate_gen_lit: (untyped) -> Array[Aua::Str]
      def translate_call: (AST::Node) -> Array[Statement]
      module Binop
        def self.binary_operation: (Symbol, statement, statement) -> statement
        def self.binop_plus: (statement, statement) -> statement
        def self.binop_minus: (statement, statement) -> statement
        def self.binop_slash: (statement, statement) -> statement
        def self.float_slash: (statement, statement) -> statement
        def self.int_slash: (Int, Int) -> statement
        def self.int_plus: (Int, Int) -> statement
        def self.float_plus: (Float, Float) -> statement
        def self.str_plus: (Str, Str) -> statement
        def self.raise_binop_type_error: (Symbol, statement, statement) -> statement
        def self.binop_star: (statement, statement) -> statement
        def self.binop_pow: (statement, statement) -> statement
      end

      TRANSLATIONS: Hash[Symbol, Array[Statement]]
    end

    extend Semantics
    def initialize: (?environment) -> void
    def builtins: () -> Hash[Symbol, untyped]

    private

    def reduce: (AST::Node) -> Array[Statement]
    def evaluate: (Context, AST::Node) -> untyped
    def evaluate_one: (Statement) -> untyped
    def eval_call: (String, Array[untyped]) -> untyped
    def eval_id: (untyped) -> untyped
    def eval_let: (untyped, untyped) -> untyped
    def eval_if: (untyped, untyped, untyped?) -> untyped
  end

  class PrettyPrinter
    def pretty: (Obj) -> String
  end

  class Interpreter
    def initialize: (?environment) -> void
    def lex: (Context, String) -> Enumerator[token]
    def parse: (Context, Enumerator[token]) -> AST::Node
    def run: (Context, String) -> untyped

    private

    def vm: () -> VM
  end

  module LLM
    class Provider
      class Error < Aua::Error
      end

      class Cache[T = untyped]
        @cache: Hash[String, T]
        @cache_miss_lambda: ^(String, T) -> void
        def fetch: (String) { () -> T } -> T

        def append_to_cache_file: (String, T, untyped) -> void
        def dump: (String) -> void
        def fetch!: (String) { () -> T } -> T
        def hydrate: (String) -> void
        def hydrate_line: (String) -> void
        def miss: () { (String, T) -> void } -> void
        def self.instance: () -> Cache[untyped]
        def self.file_path: () -> String
        def self.simple_key: (untyped) -> String
        def with_cache: (String) { () -> T } -> T
      end

      class Response
        class Metadata
          attr_reader model: String
          attr_reader requested_at: ::Time
          attr_reader responded_at: ::Time
          attr_reader duration: ::Float
          attr_reader tokens_used: Integer?
          attr_reader parameters: Hash[untyped, untyped]
          def initialize: (
            model: String, requested_at: ::Time, responded_at: ::Time,
            ?tokens_used: Integer, ?parameters: Hash[untyped, untyped]
          ) -> void
          def timing: () -> String
          def self.coerce_timestamp: (untyped) -> ::Time
        end
        attr_reader prompt: String
        attr_reader message: String
        def initialize: (prompt: String, message: String, metadata: Metadata) -> void
        def to_s: () -> String
      end

      type completion_trace = {
          message: String,
          model: String,
          prompt: String,
          tokens_used: Integer?,
          parameters: Hash[untyped, untyped],
          requested_at: ::Time,
          responded_at: ::Time
        }

      class Completion
        attr_reader model: String
        attr_reader prompt: String
        attr_reader generation: Hash[Symbol, untyped]

        def initialize: (prompt: String, model: String, generation: Hash[Symbol, untyped]) -> void

        def generate: () -> completion_trace
        def call: () -> completion_trace
        def request: (prompt: String, ?model: String, ?generation: Hash[Symbol, untyped]) -> completion_trace
        def read_response: (String, prompt: String, meta: Hash[Symbol, untyped]) -> completion_trace

        def post: (untyped, untyped) -> untyped
        def db: () -> Cache[completion_trace]
        def request_body: (String, model: String, generation: Hash[Symbol, untyped]) -> untyped
      end

      def initialize: (?base_uri: String) -> void
      def chat_completion: (prompt: String, ?model: String, ?generation: Hash[Symbol, untyped]) -> Response
      def generation_parameters: () -> Hash[Symbol, untyped]
    end

    class Chat
      def initialize: () -> void
      def ask: (String) -> String
    end

    def self.chat: () -> Chat
  end

  class Configuration
    attr_reader base_uri: String
    attr_reader model: String
    attr_reader testing: bool
    attr_reader temperature: ::Float
    attr_reader max_tokens: Integer
    attr_reader top_p: ::Float
    attr_reader frequency_penalty: ::Float
    attr_reader presence_penalty: ::Float
    def initialize: (
      ?base_uri: String, ?model: String, ?testing: bool, ?temperature: ::Float,
      ?max_tokens: Integer, ?top_p: ::Float, ?frequency_penalty: ::Float,
      ?presence_penalty: ::Float
    ) -> void
    def self.default: () -> Configuration
  end

  def self.testing: () -> bool
  def self.testing=: (bool) -> void
  def self.configure: () { (untyped) -> void } -> void
  def self.configuration: () -> Configuration

  # Constants and helpers
  EOS: token
  NOTHING: AST::Node
  LET: untyped
  RECALL: untyped
  LOCAL_VARIABLE_GET: untyped
  SEND: untyped

  def self.run: (String) -> untyped
  def self.vm: (?environment) -> VM
  def self.testing?: () -> bool
  def self.builtins: () -> Hash[Symbol, untyped]
  def self.interpreter: () -> Interpreter
end
