module Aua
  VERSION: String
  type environment = Hash[String, untyped]

  module Text
    class Cursor
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (Integer, Integer) -> void
      def advance: () -> void
      def newline: () -> void
    end

    class Document
      attr_reader text: String
      attr_reader cursor: Cursor
      attr_reader position: Integer

      def initialize: (String) -> void
      def advance: () -> void
      def peek: () -> String?
      def slice: (Integer, Integer) -> String?
      def indicate: () -> Array[String]
      def finished?: () -> bool
    end

    def self.indicate: (String, Cursor) -> Array[String]
  end

  class Token
    attr_reader type: Symbol
    attr_reader value: untyped
    def initialize: (type: Symbol, value: untyped) -> void
    def eos?: () -> bool
  end

  module Syntax
    def t: (Symbol, untyped) -> Token
         | (Symbol) -> Token
  end

  type char = String

  class Lex
    include Syntax
    MAX_TOKENS: Integer
    TOKEN_HANDLERS: Hash[untyped, Symbol]
    @tokens: Array[Token]

    def initialize: (String) -> void
    def tokens: () -> Array[Token]
    def advance: () -> void
    def current_line: () -> Integer
    def current_column: () -> Integer
    def current_char: () -> char
    def recognize: () -> Lex::Recognizer
    def eof?: () -> bool
    def unexpected_character_message: () -> String
    def lex: () -> void
    def accept: () -> void
    def current_pos: () -> Integer
    def slice_from: (Integer) -> String?

    def each_token: () { (Token) -> void } -> void
    def accept_token: () -> Token?

    def tokenize: () { (Token) -> void } -> void

    private

    def handle_whitespace: () -> void
    def handle_string: () -> void
    def handle_identifier: () -> void
    def handle_number: () -> void
    def handle_minus: () -> void
    def handle_lparen: () -> void
    def handle_rparen: () -> void
    def handle_equals: () -> void
    def handle_unexpected: () -> void

    class Recognizer
      def initialize: (Lex) -> void
      def identifier: () -> Token
      def number_lit: () -> Token
      def string: () -> Token
      def number_token_from_string: (String, bool) -> Token
      def current_char: () -> char
      def advance: () -> void
      def t: (Symbol, untyped) -> Token
           | (Symbol) -> Token
      def eof?: () -> bool
    end
  end

  module AST
    class Node
      attr_reader type: Symbol
      attr_reader value: untyped
      def initialize: (type: Symbol, value: untyped) -> void
    end
  end

  module Grammar
    attr_reader parse: Parse
    def s: (Symbol, *untyped) -> AST::Node
    class Primitives
      include Grammar
      def initialize: (Parse) -> void
      def parse_negation: () -> AST::Node
      def parse_id: () -> AST::Node
      def parse_number: () -> AST::Node
      def parse_nihil: () -> AST::Node
      def parse_float: () -> AST::Node
      def parse_bool: () -> AST::Node
      def parse_str: () -> AST::Node
      def parse_parens: () -> AST::Node
    end
  end
  def self.s: (Symbol, *untyped) -> AST::Node


  class Parse
    include Grammar
    include Syntax
    PRIMARY_MAP: Hash[Symbol, Symbol]

    attr_reader current_token: Token
    def initialize: (Array[Token]) -> void
    def tree: () -> AST::Node
    def consume: (Symbol) -> void
    def next_token: () -> Token?
    def peek_token: () -> Token?
    def parse: () -> AST::Node
    def parse_expression: () -> AST::Node
    def parse_primary: () -> AST::Node
    def unexpected_tokens?: () -> bool
    def unexpected_token: () -> untyped
    def self.ast: (Array[Token]) -> AST::Node
  end

  class Obj
    def klass: () -> Klass
  end

  class Klass < Obj
    def initialize: (String, Obj) -> void
    def klass: () -> Klass
    def self.klass: () -> Klass
    def self.obj: () -> Klass
  end

  class Nihil < Obj
    def klass: () -> Klass
    def name: () -> String
    def value: () -> nil
  end

  class Int < Obj
    def initialize: (Integer) -> void
    def klass: () -> Klass
    def name: () -> String
    attr_reader value: Integer
  end

  class Float < Obj
    def initialize: (Float) -> void
    def klass: () -> Klass
    def name: () -> String
    attr_reader value: Float
  end

  class Str < Obj
    def initialize: (String) -> void
    def klass: () -> Klass
    def name: () -> String
    attr_reader value: String
  end

  class Bool < Obj
    def initialize: (bool) -> void
    def klass: () -> Klass
    def name: () -> String
    attr_reader value: bool
  end

  class Statement
    attr_reader type: Symbol
    attr_reader value: untyped
    def initialize: (type: Symbol, value: untyped) -> void
  end

  module Semantics
    def self.inst: (Symbol, *untyped) -> Statement
    MEMO : String
  end

  class VM
    extend Semantics
    def initialize: (?environment) -> void
    def recall_primary: (AST::Node) -> Array[Statement]
    def translate_negation: (AST::Node) -> Array[Statement]
    def translate: (AST::Node) -> Array[Statement]
    def evaluate: (AST::Node) -> untyped
    def evaluate_one: (Statement) -> untyped
    def translate_assignment: (AST::Node) -> Array[Statement]
    TRANSLATIONS: Hash[Symbol, Array[Statement]]
  end

  class PrettyPrinter
    def pretty: (Obj) -> String
  end

  class Interpreter
    def initialize: (?environment) -> void
    def lex: (String) -> Array[Token]
    def parse: (Array[Token]) -> AST::Node
    def vm: () -> VM
    def run: (String) -> untyped
  end

  class Error < StandardError
  end


  # Constants and helpers
  EOS: Token
  NOTHING: AST::Node
  LET: untyped
  RECALL: untyped

  def self.run: (String) -> untyped
end

