module Aua
  VERSION: String
  type environment = Hash[String, untyped]

  type char = String

  module Text
    class Cursor
      attr_reader line: Integer
      attr_reader column: Integer

      def initialize: (Integer, Integer) -> void
      def advance: () -> void
      def newline: () -> void
    end

    class Document
      attr_reader text: String
      attr_reader cursor: Cursor
      attr_reader position: Integer

      def initialize: (String) -> void
      def advance: () -> void
      def current: () -> char?
      def peek: () -> char?
      def peek_at: (Integer) -> char?
      def peek_n: (Integer) -> Array[char]
      def slice: (Integer, Integer) -> String?
      def indicate: () -> Array[String]
      def finished?: () -> bool
    end

    def self.indicate: (String, Cursor) -> Array[String]
  end

  module Syntax
    def t: (Symbol, untyped) -> Token
         | (Symbol) -> Token

    class Token
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Text::Cursor
      def initialize: (type: Symbol, value: untyped, at: Text::Cursor) -> void
    end

    ONE_CHAR_TOKEN_NAMES: Hash[String, Symbol]
    TWO_CHAR_TOKEN_NAMES: Hash[String, Symbol]
    THREE_CHAR_TOKEN_NAMES: Hash[String, Symbol]
  end

  type token = Syntax::Token
  type matchy = Regexp | String

  class Lex
    include Syntax
    MAX_TOKENS: Integer
    class Lens
      def initialize: (Text::Document) -> void
      def current_pos: () -> Integer
      def current_line: () -> Integer
      def current_column: () -> Integer
      def current_char: () -> char
      def describe: () -> String
      def describe_character: (char) -> String
      def identify: (message: String, hint: String) -> String
    end
    @tokens: Array[token]
    @doc: Text::Document
    @lens: Lens
    def initialize: (String) -> void
    def tokens: () -> Array[token]
    def advance: () -> void
    def current_line: () -> Integer
    def current_column: () -> Integer
    def current_char: () -> char
    def recognize: () -> Lex::Recognizer
    def eof?: () -> bool
    def unexpected_character_message: () -> String
    def lex: () -> void
    def accept: () -> untyped
    def accept_one: (char?) -> untyped
    def accept_two: (char?, char?) -> untyped
    def accept_three: (char?, char?, char?) -> untyped
    def current_pos: () -> Integer
    def slice_from: (Integer) -> String?
    def each_token: () { (token) -> void } -> void
    def accept_token: () -> token?
    def tokenize: () { (token) -> void } -> void

    private

    def handle_plus: () -> token?
    def handle_star: () -> token?
    def handle_slash: () -> token?
    def handle_pow: () -> token?
    def handle_lparen: () -> token?
    def handle_rparen: () -> token?
    def handle_number: () -> token?
    def handle_equals: () -> token?
    def handle_identifier: () -> token?
    def handle_string: () -> token?
    def handle_minus: () -> token?
    def handle_whitespace: () -> void
    def handle_unexpected: () -> void

    class Recognizer
      KEYWORDS : Set[Symbol]
      MAX_STRING_LENGTH: Integer
      def initialize: (Lex) -> void
      def identifier: () -> token
      def number_lit: () -> token
      def string: () -> token
      def number_token_from_string: (String, bool) -> token
      def current_char: () -> char
      def advance: () -> void
      def t: (Symbol, untyped) -> token
           | (Symbol, untyped, untyped) -> token
           | (Symbol) -> token
      def eof?: () -> bool
      def current_pos: () -> Integer

      private

      def invalid_token_message: (String) -> String
      def check_number_followed_by_identifier: () -> void
    end
  end

  module AST
    class Node
      attr_reader type: Symbol
      attr_reader value: untyped
      attr_reader location: Text::Cursor
      def initialize: (type: Symbol, value: untyped, at: Text::Cursor) -> void
    end
  end

  module Grammar
    PRIMARY_NAMES: Hash[Symbol, Symbol]
    BINARY_PRECEDENCE: Hash[Symbol, Integer]

    attr_reader parse: Parse
    def s: (Symbol, *untyped) -> AST::Node
    class Primitives
      include Grammar
      def initialize: (Parse) -> void
      def parse_negation: () -> AST::Node
      def parse_id: () -> AST::Node
      def parse_int: () -> AST::Node
      def parse_nihil: () -> AST::Node
      def parse_float: () -> AST::Node
      def parse_bool: () -> AST::Node
      def parse_str: () -> AST::Node
      def parse_parens: () -> AST::Node

      private

      def parse_one: (Symbol) -> AST::Node
    end
  end
  def self.s: (Symbol, *untyped) -> AST::Node

  class Parse
    include Grammar
    include Syntax
    @tokens: Enumerator[token]
    @buffer: Array[token]

    attr_reader current_token: token
    def initialize: (Enumerator[token]) -> void
    def tree: () -> AST::Node
    def consume: (Symbol) -> void
               | (Symbol, untyped?) -> void
    def next_token: () -> token?
    def peek_token: () -> token?
    def parse: () -> AST::Node
    def parse_expression: () -> AST::Node
    def parse_assignment: () -> AST::Node?
    def parse_binop: (?Integer) -> AST::Node
    def parse_primary: () -> AST::Node
    def parse_conditional: () -> AST::Node?
    def parse_condition_body: () -> [AST::Node, AST::Node?]
    def unexpected_tokens?: () -> bool
    def unexpected_token: () -> untyped
    def self.ast: (Array[token]) -> AST::Node
    def binary_op?: (Symbol) -> bool
    def advance: () -> void

    def precedent?: (Symbol, Integer) -> bool
    def consume_binary_op: (AST::Node) -> AST::Node
  end

  class Obj
    def klass: () -> Klass
    def introspect: () -> String
  end

  class Klass < Obj
    def initialize: (String, Obj) -> void
    def klass: () -> Klass
    def introspect: () -> String
    def self.klass: () -> Klass
    def self.obj: () -> Klass
  end

  class Nihil < Obj
    def klass: () -> Klass
    def name: () -> String
    def value: () -> nil
    def introspect: () -> String
  end

  class Int < Obj
    def initialize: (Integer) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: Integer
  end

  class Float < Obj
    def initialize: (::Float) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: ::Float
  end

  class Str < Obj
    def initialize: (String) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: String
  end

  class Bool < Obj
    def initialize: (bool) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: bool
  end

  class Box[T] < Obj
    def initialize: (T) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
    attr_reader value: T
  end

  class Rec < Box[Hash[String, Obj]]
    def initialize: (String, Hash[String, Obj]) -> void
    def klass: () -> Klass
    def name: () -> String
    def introspect: () -> String
  end

  class Statement
    attr_reader type: Symbol
    attr_reader value: untyped
    def initialize: (type: Symbol, value: untyped) -> void
  end

  module Semantics
    MEMO: String
    def self.inst: (Symbol, *untyped) -> Statement
  end

  type primary = Int | Float | Str | Bool | Nihil
  type statement = Array[Statement] | Statement | primary

  class VM
    extend Semantics
    def initialize: (?environment) -> void

    private

    def reduce: (AST::Node) -> Array[Statement]
    def evaluate: (AST::Node) -> untyped
    def evaluate_one: (Statement) -> untyped
    def eval_id: (untyped) -> untyped
    def eval_let: (untyped, untyped) -> untyped
    def eval_if: (untyped, untyped, untyped?) -> untyped
    class Translator
      def initialize: (VM) -> void
      def environment: () -> environment
      def reify_primary: (AST::Node) -> primary
      def translate_negation: (AST::Node) -> Array[Statement]
      def translate: (AST::Node) -> statement
      def translate_assignment: (AST::Node) -> Array[Statement]
      def translate_binop: (AST::Node) -> statement
      def translate_if: (AST::Node) -> statement
      module Binop
        def self.binary_operation: (Symbol, statement, statement) -> statement
        def self.binop_plus: (statement, statement) -> statement
        def self.binop_minus: (statement, statement) -> statement
        def self.binop_slash: (statement, statement) -> statement
        def self.float_slash: (statement, statement) -> statement
        def self.int_slash: (Int, Int) -> statement
        def self.int_plus: (Int, Int) -> statement
        def self.float_plus: (Float, Float) -> statement
        def self.str_plus: (Str, Str) -> statement
        def self.raise_binop_type_error: (Symbol, statement, statement) -> statement
        def self.binop_star: (statement, statement) -> statement
        def self.binop_pow: (statement, statement) -> statement
      end

      TRANSLATIONS: Hash[Symbol, Array[Statement]]
    end
  end

  class PrettyPrinter
    def pretty: (Obj) -> String
  end

  class Context
    def source_document: () -> Text::Document
  end

  class Interpreter
    def initialize: (?environment) -> void
    def lex:   (Context, String) -> Enumerator[token]
    def parse: (Context, Enumerator[token]) -> AST::Node
    def vm:    (Context, ) -> VM
    def run:   (Context, String) -> untyped
  end

  class Error < StandardError
  end

  # Constants and helpers
  EOS: token
  NOTHING: AST::Node
  LET: untyped
  RECALL: untyped
  LOCAL_VARIABLE_GET: untyped
  SEND: untyped

  def self.run: (String) -> untyped
  
  def self.configuration: () -> config
end
