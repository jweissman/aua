#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "aua"
require "readline"
require "rainbow/refinement"
using Rainbow

require "optparse"

def color_for(klass)
  case klass
  when Aua::Int then :blue
  when Aua::Float then :green
  when Aua::Str then :yellow
  when Aua::Bool then :magenta
  when Aua::Nihil then :red
  else :black
  end
end

def info(msg) = $stdout.puts(msg)

HISTFILE = File.expand_path("~/.aua_history")

def repl!
  File.readlines(HISTFILE, chomp: true).each { |line| Readline::HISTORY.push(line) } if File.exist?(HISTFILE)

  at_exit do
    File.write(HISTFILE, Readline::HISTORY.to_a.last(1000).join("\n"))
  end

  loop { rep! }
end

def rep!
  input = Readline.readline("aura >> ".black, true)
  bye if input.nil? || input.strip == "exit"
  return if input.strip.empty?

  result = Aua.run(input)
  info result.pretty.color(color_for(result.class)).bright
rescue Interrupt
  warn "\nExiting shell..."
  bye(0)
rescue StandardError => e
  warn "An error occurred: #{e.message}"
  warn e.backtrace.join("\n").color(:red)
  info "Please try again."
end

def bye(code = 0)
  puts "#{"-".green}|#{"~".blue}"
  puts "(c) 2023-2024 aura-lang"
  exit(code)
end

puts "#{"~".blue}|#{"-".green}"
if ARGV.empty?
  repl!
else
  # We want to parse options, something like:
  # opts = ARGV.getopts("r", "rerun", "reenter-constantly")
  # puts "Running in file mode with options: #{opts.inspect}"

  # Using optparse:
  options = {}
  opt_parser = OptionParser.new do |opts|
    opts.banner = "Usage: aura [options] [file1 file2 ...]"
    opts.on("-r", "--reenter-constantly", "Continuously reenter the file until stopped") do
      options[:rerun] = true
    end
  end
  begin
    opt_parser.parse!(ARGV)
  rescue OptionParser::ParseError => e
    warn "Error parsing options: #{e.message}"
    puts opts
    exit(1)
  end

  files = ARGV.empty? ? nil : ARGV
  puts "Running in file mode with options: #{options.inspect}"
  puts "Processing files: #{files.inspect}" if files

  files.each do |file|
    content = File.read(file)
    result = Aua.run(content)
    puts result.pretty.color(color_for(result.class)).bright
  rescue StandardError => e
    warn "Error processing file #{file}: #{e.message}"
    puts e.backtrace.join("\n").color(:red)
  end
end
